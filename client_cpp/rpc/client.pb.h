// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_client_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_client_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_client_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_client_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_client_2eproto;
namespace rpc {
class ConfigRequest;
struct ConfigRequestDefaultTypeInternal;
extern ConfigRequestDefaultTypeInternal _ConfigRequest_default_instance_;
class ConfigResponse;
struct ConfigResponseDefaultTypeInternal;
extern ConfigResponseDefaultTypeInternal _ConfigResponse_default_instance_;
class QueryNewPointRequest;
struct QueryNewPointRequestDefaultTypeInternal;
extern QueryNewPointRequestDefaultTypeInternal _QueryNewPointRequest_default_instance_;
class QueryNewPointResponse;
struct QueryNewPointResponseDefaultTypeInternal;
extern QueryNewPointResponseDefaultTypeInternal _QueryNewPointResponse_default_instance_;
class QueryRangeRequest;
struct QueryRangeRequestDefaultTypeInternal;
extern QueryRangeRequestDefaultTypeInternal _QueryRangeRequest_default_instance_;
class QueryRangeResponse;
struct QueryRangeResponseDefaultTypeInternal;
extern QueryRangeResponseDefaultTypeInternal _QueryRangeResponse_default_instance_;
class QuerySeriesRequest;
struct QuerySeriesRequestDefaultTypeInternal;
extern QuerySeriesRequestDefaultTypeInternal _QuerySeriesRequest_default_instance_;
class QuerySeriesResponse;
struct QuerySeriesResponseDefaultTypeInternal;
extern QuerySeriesResponseDefaultTypeInternal _QuerySeriesResponse_default_instance_;
class QueryTagValuesRequest;
struct QueryTagValuesRequestDefaultTypeInternal;
extern QueryTagValuesRequestDefaultTypeInternal _QueryTagValuesRequest_default_instance_;
class QueryTagValuesResponse;
struct QueryTagValuesResponseDefaultTypeInternal;
extern QueryTagValuesResponseDefaultTypeInternal _QueryTagValuesResponse_default_instance_;
class WritePointsRequest;
struct WritePointsRequestDefaultTypeInternal;
extern WritePointsRequestDefaultTypeInternal _WritePointsRequest_default_instance_;
class WritePointsResponse;
struct WritePointsResponseDefaultTypeInternal;
extern WritePointsResponseDefaultTypeInternal _WritePointsResponse_default_instance_;
}  // namespace rpc
PROTOBUF_NAMESPACE_OPEN
template<> ::rpc::ConfigRequest* Arena::CreateMaybeMessage<::rpc::ConfigRequest>(Arena*);
template<> ::rpc::ConfigResponse* Arena::CreateMaybeMessage<::rpc::ConfigResponse>(Arena*);
template<> ::rpc::QueryNewPointRequest* Arena::CreateMaybeMessage<::rpc::QueryNewPointRequest>(Arena*);
template<> ::rpc::QueryNewPointResponse* Arena::CreateMaybeMessage<::rpc::QueryNewPointResponse>(Arena*);
template<> ::rpc::QueryRangeRequest* Arena::CreateMaybeMessage<::rpc::QueryRangeRequest>(Arena*);
template<> ::rpc::QueryRangeResponse* Arena::CreateMaybeMessage<::rpc::QueryRangeResponse>(Arena*);
template<> ::rpc::QuerySeriesRequest* Arena::CreateMaybeMessage<::rpc::QuerySeriesRequest>(Arena*);
template<> ::rpc::QuerySeriesResponse* Arena::CreateMaybeMessage<::rpc::QuerySeriesResponse>(Arena*);
template<> ::rpc::QueryTagValuesRequest* Arena::CreateMaybeMessage<::rpc::QueryTagValuesRequest>(Arena*);
template<> ::rpc::QueryTagValuesResponse* Arena::CreateMaybeMessage<::rpc::QueryTagValuesResponse>(Arena*);
template<> ::rpc::WritePointsRequest* Arena::CreateMaybeMessage<::rpc::WritePointsRequest>(Arena*);
template<> ::rpc::WritePointsResponse* Arena::CreateMaybeMessage<::rpc::WritePointsResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace rpc {

// ===================================================================

class WritePointsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.WritePointsRequest) */ {
 public:
  inline WritePointsRequest() : WritePointsRequest(nullptr) {}
  ~WritePointsRequest() override;
  explicit PROTOBUF_CONSTEXPR WritePointsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WritePointsRequest(const WritePointsRequest& from);
  WritePointsRequest(WritePointsRequest&& from) noexcept
    : WritePointsRequest() {
    *this = ::std::move(from);
  }

  inline WritePointsRequest& operator=(const WritePointsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WritePointsRequest& operator=(WritePointsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WritePointsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WritePointsRequest* internal_default_instance() {
    return reinterpret_cast<const WritePointsRequest*>(
               &_WritePointsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WritePointsRequest& a, WritePointsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WritePointsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WritePointsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WritePointsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WritePointsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WritePointsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WritePointsRequest& from) {
    WritePointsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WritePointsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.WritePointsRequest";
  }
  protected:
  explicit WritePointsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
  };
  // string row = 1;
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // @@protoc_insertion_point(class_scope:rpc.WritePointsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class WritePointsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.WritePointsResponse) */ {
 public:
  inline WritePointsResponse() : WritePointsResponse(nullptr) {}
  ~WritePointsResponse() override;
  explicit PROTOBUF_CONSTEXPR WritePointsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WritePointsResponse(const WritePointsResponse& from);
  WritePointsResponse(WritePointsResponse&& from) noexcept
    : WritePointsResponse() {
    *this = ::std::move(from);
  }

  inline WritePointsResponse& operator=(const WritePointsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WritePointsResponse& operator=(WritePointsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WritePointsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WritePointsResponse* internal_default_instance() {
    return reinterpret_cast<const WritePointsResponse*>(
               &_WritePointsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WritePointsResponse& a, WritePointsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WritePointsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WritePointsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WritePointsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WritePointsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WritePointsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WritePointsResponse& from) {
    WritePointsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WritePointsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.WritePointsResponse";
  }
  protected:
  explicit WritePointsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 2,
  };
  // string reply = 2;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:rpc.WritePointsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QuerySeriesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QuerySeriesRequest) */ {
 public:
  inline QuerySeriesRequest() : QuerySeriesRequest(nullptr) {}
  ~QuerySeriesRequest() override;
  explicit PROTOBUF_CONSTEXPR QuerySeriesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySeriesRequest(const QuerySeriesRequest& from);
  QuerySeriesRequest(QuerySeriesRequest&& from) noexcept
    : QuerySeriesRequest() {
    *this = ::std::move(from);
  }

  inline QuerySeriesRequest& operator=(const QuerySeriesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySeriesRequest& operator=(QuerySeriesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySeriesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySeriesRequest* internal_default_instance() {
    return reinterpret_cast<const QuerySeriesRequest*>(
               &_QuerySeriesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QuerySeriesRequest& a, QuerySeriesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySeriesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySeriesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySeriesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySeriesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySeriesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySeriesRequest& from) {
    QuerySeriesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySeriesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QuerySeriesRequest";
  }
  protected:
  explicit QuerySeriesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
  };
  // string tags = 3;
  void clear_tags();
  const std::string& tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tags();
  PROTOBUF_NODISCARD std::string* release_tags();
  void set_allocated_tags(std::string* tags);
  private:
  const std::string& _internal_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tags(const std::string& value);
  std::string* _internal_mutable_tags();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QuerySeriesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QuerySeriesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QuerySeriesResponse) */ {
 public:
  inline QuerySeriesResponse() : QuerySeriesResponse(nullptr) {}
  ~QuerySeriesResponse() override;
  explicit PROTOBUF_CONSTEXPR QuerySeriesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySeriesResponse(const QuerySeriesResponse& from);
  QuerySeriesResponse(QuerySeriesResponse&& from) noexcept
    : QuerySeriesResponse() {
    *this = ::std::move(from);
  }

  inline QuerySeriesResponse& operator=(const QuerySeriesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySeriesResponse& operator=(QuerySeriesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySeriesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySeriesResponse* internal_default_instance() {
    return reinterpret_cast<const QuerySeriesResponse*>(
               &_QuerySeriesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(QuerySeriesResponse& a, QuerySeriesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySeriesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySeriesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuerySeriesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuerySeriesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySeriesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuerySeriesResponse& from) {
    QuerySeriesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySeriesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QuerySeriesResponse";
  }
  protected:
  explicit QuerySeriesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 4,
  };
  // string reply = 4;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QuerySeriesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class ConfigRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.ConfigRequest) */ {
 public:
  inline ConfigRequest() : ConfigRequest(nullptr) {}
  ~ConfigRequest() override;
  explicit PROTOBUF_CONSTEXPR ConfigRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigRequest(const ConfigRequest& from);
  ConfigRequest(ConfigRequest&& from) noexcept
    : ConfigRequest() {
    *this = ::std::move(from);
  }

  inline ConfigRequest& operator=(const ConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigRequest& operator=(ConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigRequest*>(
               &_ConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConfigRequest& a, ConfigRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigRequest& from) {
    ConfigRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.ConfigRequest";
  }
  protected:
  explicit ConfigRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 11,
  };
  // string name = 11;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:rpc.ConfigRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class ConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.ConfigResponse) */ {
 public:
  inline ConfigResponse() : ConfigResponse(nullptr) {}
  ~ConfigResponse() override;
  explicit PROTOBUF_CONSTEXPR ConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigResponse(const ConfigResponse& from);
  ConfigResponse(ConfigResponse&& from) noexcept
    : ConfigResponse() {
    *this = ::std::move(from);
  }

  inline ConfigResponse& operator=(const ConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigResponse& operator=(ConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigResponse*>(
               &_ConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConfigResponse& a, ConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigResponse& from) {
    ConfigResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.ConfigResponse";
  }
  protected:
  explicit ConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 6,
  };
  // string reply = 6;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:rpc.ConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QueryRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QueryRangeRequest) */ {
 public:
  inline QueryRangeRequest() : QueryRangeRequest(nullptr) {}
  ~QueryRangeRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRangeRequest(const QueryRangeRequest& from);
  QueryRangeRequest(QueryRangeRequest&& from) noexcept
    : QueryRangeRequest() {
    *this = ::std::move(from);
  }

  inline QueryRangeRequest& operator=(const QueryRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRangeRequest& operator=(QueryRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRangeRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRangeRequest*>(
               &_QueryRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryRangeRequest& a, QueryRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRangeRequest& from) {
    QueryRangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QueryRangeRequest";
  }
  protected:
  explicit QueryRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricTagsFieldNumber = 7,
  };
  // string metric_tags = 7;
  void clear_metric_tags();
  const std::string& metric_tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metric_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metric_tags();
  PROTOBUF_NODISCARD std::string* release_metric_tags();
  void set_allocated_metric_tags(std::string* metric_tags);
  private:
  const std::string& _internal_metric_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metric_tags(const std::string& value);
  std::string* _internal_mutable_metric_tags();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QueryRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_tags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QueryRangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QueryRangeResponse) */ {
 public:
  inline QueryRangeResponse() : QueryRangeResponse(nullptr) {}
  ~QueryRangeResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryRangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRangeResponse(const QueryRangeResponse& from);
  QueryRangeResponse(QueryRangeResponse&& from) noexcept
    : QueryRangeResponse() {
    *this = ::std::move(from);
  }

  inline QueryRangeResponse& operator=(const QueryRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRangeResponse& operator=(QueryRangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRangeResponse* internal_default_instance() {
    return reinterpret_cast<const QueryRangeResponse*>(
               &_QueryRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryRangeResponse& a, QueryRangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRangeResponse& from) {
    QueryRangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QueryRangeResponse";
  }
  protected:
  explicit QueryRangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 8,
  };
  // string reply = 8;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QueryRangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QueryTagValuesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QueryTagValuesRequest) */ {
 public:
  inline QueryTagValuesRequest() : QueryTagValuesRequest(nullptr) {}
  ~QueryTagValuesRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryTagValuesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTagValuesRequest(const QueryTagValuesRequest& from);
  QueryTagValuesRequest(QueryTagValuesRequest&& from) noexcept
    : QueryTagValuesRequest() {
    *this = ::std::move(from);
  }

  inline QueryTagValuesRequest& operator=(const QueryTagValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTagValuesRequest& operator=(QueryTagValuesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTagValuesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTagValuesRequest* internal_default_instance() {
    return reinterpret_cast<const QueryTagValuesRequest*>(
               &_QueryTagValuesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(QueryTagValuesRequest& a, QueryTagValuesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTagValuesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTagValuesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTagValuesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTagValuesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTagValuesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTagValuesRequest& from) {
    QueryTagValuesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTagValuesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QueryTagValuesRequest";
  }
  protected:
  explicit QueryTagValuesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 9,
  };
  // string tag = 9;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QueryTagValuesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QueryTagValuesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QueryTagValuesResponse) */ {
 public:
  inline QueryTagValuesResponse() : QueryTagValuesResponse(nullptr) {}
  ~QueryTagValuesResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryTagValuesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTagValuesResponse(const QueryTagValuesResponse& from);
  QueryTagValuesResponse(QueryTagValuesResponse&& from) noexcept
    : QueryTagValuesResponse() {
    *this = ::std::move(from);
  }

  inline QueryTagValuesResponse& operator=(const QueryTagValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTagValuesResponse& operator=(QueryTagValuesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTagValuesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTagValuesResponse* internal_default_instance() {
    return reinterpret_cast<const QueryTagValuesResponse*>(
               &_QueryTagValuesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(QueryTagValuesResponse& a, QueryTagValuesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTagValuesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTagValuesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryTagValuesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryTagValuesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTagValuesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryTagValuesResponse& from) {
    QueryTagValuesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTagValuesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QueryTagValuesResponse";
  }
  protected:
  explicit QueryTagValuesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 10,
  };
  // string reply = 10;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QueryTagValuesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QueryNewPointRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QueryNewPointRequest) */ {
 public:
  inline QueryNewPointRequest() : QueryNewPointRequest(nullptr) {}
  ~QueryNewPointRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryNewPointRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryNewPointRequest(const QueryNewPointRequest& from);
  QueryNewPointRequest(QueryNewPointRequest&& from) noexcept
    : QueryNewPointRequest() {
    *this = ::std::move(from);
  }

  inline QueryNewPointRequest& operator=(const QueryNewPointRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNewPointRequest& operator=(QueryNewPointRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNewPointRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNewPointRequest* internal_default_instance() {
    return reinterpret_cast<const QueryNewPointRequest*>(
               &_QueryNewPointRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(QueryNewPointRequest& a, QueryNewPointRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryNewPointRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNewPointRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNewPointRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryNewPointRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryNewPointRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryNewPointRequest& from) {
    QueryNewPointRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryNewPointRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QueryNewPointRequest";
  }
  protected:
  explicit QueryNewPointRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 11,
  };
  // string tag = 11;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QueryNewPointRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// -------------------------------------------------------------------

class QueryNewPointResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rpc.QueryNewPointResponse) */ {
 public:
  inline QueryNewPointResponse() : QueryNewPointResponse(nullptr) {}
  ~QueryNewPointResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryNewPointResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryNewPointResponse(const QueryNewPointResponse& from);
  QueryNewPointResponse(QueryNewPointResponse&& from) noexcept
    : QueryNewPointResponse() {
    *this = ::std::move(from);
  }

  inline QueryNewPointResponse& operator=(const QueryNewPointResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNewPointResponse& operator=(QueryNewPointResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNewPointResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNewPointResponse* internal_default_instance() {
    return reinterpret_cast<const QueryNewPointResponse*>(
               &_QueryNewPointResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QueryNewPointResponse& a, QueryNewPointResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryNewPointResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNewPointResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNewPointResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryNewPointResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryNewPointResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryNewPointResponse& from) {
    QueryNewPointResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryNewPointResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rpc.QueryNewPointResponse";
  }
  protected:
  explicit QueryNewPointResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 12,
  };
  // string reply = 12;
  void clear_reply();
  const std::string& reply() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply();
  PROTOBUF_NODISCARD std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  private:
  const std::string& _internal_reply() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // @@protoc_insertion_point(class_scope:rpc.QueryNewPointResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_client_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WritePointsRequest

// string row = 1;
inline void WritePointsRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
}
inline const std::string& WritePointsRequest::row() const {
  // @@protoc_insertion_point(field_get:rpc.WritePointsRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WritePointsRequest::set_row(ArgT0&& arg0, ArgT... args) {
 
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.WritePointsRequest.row)
}
inline std::string* WritePointsRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:rpc.WritePointsRequest.row)
  return _s;
}
inline const std::string& WritePointsRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void WritePointsRequest::_internal_set_row(const std::string& value) {
  
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* WritePointsRequest::_internal_mutable_row() {
  
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* WritePointsRequest::release_row() {
  // @@protoc_insertion_point(field_release:rpc.WritePointsRequest.row)
  return _impl_.row_.Release();
}
inline void WritePointsRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    
  } else {
    
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.WritePointsRequest.row)
}

// -------------------------------------------------------------------

// WritePointsResponse

// string reply = 2;
inline void WritePointsResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& WritePointsResponse::reply() const {
  // @@protoc_insertion_point(field_get:rpc.WritePointsResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WritePointsResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.WritePointsResponse.reply)
}
inline std::string* WritePointsResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:rpc.WritePointsResponse.reply)
  return _s;
}
inline const std::string& WritePointsResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void WritePointsResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* WritePointsResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* WritePointsResponse::release_reply() {
  // @@protoc_insertion_point(field_release:rpc.WritePointsResponse.reply)
  return _impl_.reply_.Release();
}
inline void WritePointsResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.WritePointsResponse.reply)
}

// -------------------------------------------------------------------

// QuerySeriesRequest

// string tags = 3;
inline void QuerySeriesRequest::clear_tags() {
  _impl_.tags_.ClearToEmpty();
}
inline const std::string& QuerySeriesRequest::tags() const {
  // @@protoc_insertion_point(field_get:rpc.QuerySeriesRequest.tags)
  return _internal_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySeriesRequest::set_tags(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tags_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QuerySeriesRequest.tags)
}
inline std::string* QuerySeriesRequest::mutable_tags() {
  std::string* _s = _internal_mutable_tags();
  // @@protoc_insertion_point(field_mutable:rpc.QuerySeriesRequest.tags)
  return _s;
}
inline const std::string& QuerySeriesRequest::_internal_tags() const {
  return _impl_.tags_.Get();
}
inline void QuerySeriesRequest::_internal_set_tags(const std::string& value) {
  
  _impl_.tags_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySeriesRequest::_internal_mutable_tags() {
  
  return _impl_.tags_.Mutable(GetArenaForAllocation());
}
inline std::string* QuerySeriesRequest::release_tags() {
  // @@protoc_insertion_point(field_release:rpc.QuerySeriesRequest.tags)
  return _impl_.tags_.Release();
}
inline void QuerySeriesRequest::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    
  } else {
    
  }
  _impl_.tags_.SetAllocated(tags, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tags_.IsDefault()) {
    _impl_.tags_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QuerySeriesRequest.tags)
}

// -------------------------------------------------------------------

// QuerySeriesResponse

// string reply = 4;
inline void QuerySeriesResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& QuerySeriesResponse::reply() const {
  // @@protoc_insertion_point(field_get:rpc.QuerySeriesResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySeriesResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QuerySeriesResponse.reply)
}
inline std::string* QuerySeriesResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:rpc.QuerySeriesResponse.reply)
  return _s;
}
inline const std::string& QuerySeriesResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void QuerySeriesResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* QuerySeriesResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* QuerySeriesResponse::release_reply() {
  // @@protoc_insertion_point(field_release:rpc.QuerySeriesResponse.reply)
  return _impl_.reply_.Release();
}
inline void QuerySeriesResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QuerySeriesResponse.reply)
}

// -------------------------------------------------------------------

// ConfigRequest

// string name = 11;
inline void ConfigRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ConfigRequest::name() const {
  // @@protoc_insertion_point(field_get:rpc.ConfigRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.ConfigRequest.name)
}
inline std::string* ConfigRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:rpc.ConfigRequest.name)
  return _s;
}
inline const std::string& ConfigRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ConfigRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigRequest::release_name() {
  // @@protoc_insertion_point(field_release:rpc.ConfigRequest.name)
  return _impl_.name_.Release();
}
inline void ConfigRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.ConfigRequest.name)
}

// -------------------------------------------------------------------

// ConfigResponse

// string reply = 6;
inline void ConfigResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& ConfigResponse::reply() const {
  // @@protoc_insertion_point(field_get:rpc.ConfigResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.ConfigResponse.reply)
}
inline std::string* ConfigResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:rpc.ConfigResponse.reply)
  return _s;
}
inline const std::string& ConfigResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void ConfigResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigResponse::release_reply() {
  // @@protoc_insertion_point(field_release:rpc.ConfigResponse.reply)
  return _impl_.reply_.Release();
}
inline void ConfigResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.ConfigResponse.reply)
}

// -------------------------------------------------------------------

// QueryRangeRequest

// string metric_tags = 7;
inline void QueryRangeRequest::clear_metric_tags() {
  _impl_.metric_tags_.ClearToEmpty();
}
inline const std::string& QueryRangeRequest::metric_tags() const {
  // @@protoc_insertion_point(field_get:rpc.QueryRangeRequest.metric_tags)
  return _internal_metric_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRangeRequest::set_metric_tags(ArgT0&& arg0, ArgT... args) {
 
 _impl_.metric_tags_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QueryRangeRequest.metric_tags)
}
inline std::string* QueryRangeRequest::mutable_metric_tags() {
  std::string* _s = _internal_mutable_metric_tags();
  // @@protoc_insertion_point(field_mutable:rpc.QueryRangeRequest.metric_tags)
  return _s;
}
inline const std::string& QueryRangeRequest::_internal_metric_tags() const {
  return _impl_.metric_tags_.Get();
}
inline void QueryRangeRequest::_internal_set_metric_tags(const std::string& value) {
  
  _impl_.metric_tags_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryRangeRequest::_internal_mutable_metric_tags() {
  
  return _impl_.metric_tags_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryRangeRequest::release_metric_tags() {
  // @@protoc_insertion_point(field_release:rpc.QueryRangeRequest.metric_tags)
  return _impl_.metric_tags_.Release();
}
inline void QueryRangeRequest::set_allocated_metric_tags(std::string* metric_tags) {
  if (metric_tags != nullptr) {
    
  } else {
    
  }
  _impl_.metric_tags_.SetAllocated(metric_tags, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.metric_tags_.IsDefault()) {
    _impl_.metric_tags_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QueryRangeRequest.metric_tags)
}

// -------------------------------------------------------------------

// QueryRangeResponse

// string reply = 8;
inline void QueryRangeResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& QueryRangeResponse::reply() const {
  // @@protoc_insertion_point(field_get:rpc.QueryRangeResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRangeResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QueryRangeResponse.reply)
}
inline std::string* QueryRangeResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:rpc.QueryRangeResponse.reply)
  return _s;
}
inline const std::string& QueryRangeResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void QueryRangeResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryRangeResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryRangeResponse::release_reply() {
  // @@protoc_insertion_point(field_release:rpc.QueryRangeResponse.reply)
  return _impl_.reply_.Release();
}
inline void QueryRangeResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QueryRangeResponse.reply)
}

// -------------------------------------------------------------------

// QueryTagValuesRequest

// string tag = 9;
inline void QueryTagValuesRequest::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& QueryTagValuesRequest::tag() const {
  // @@protoc_insertion_point(field_get:rpc.QueryTagValuesRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTagValuesRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QueryTagValuesRequest.tag)
}
inline std::string* QueryTagValuesRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:rpc.QueryTagValuesRequest.tag)
  return _s;
}
inline const std::string& QueryTagValuesRequest::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void QueryTagValuesRequest::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTagValuesRequest::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryTagValuesRequest::release_tag() {
  // @@protoc_insertion_point(field_release:rpc.QueryTagValuesRequest.tag)
  return _impl_.tag_.Release();
}
inline void QueryTagValuesRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QueryTagValuesRequest.tag)
}

// -------------------------------------------------------------------

// QueryTagValuesResponse

// string reply = 10;
inline void QueryTagValuesResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& QueryTagValuesResponse::reply() const {
  // @@protoc_insertion_point(field_get:rpc.QueryTagValuesResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTagValuesResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QueryTagValuesResponse.reply)
}
inline std::string* QueryTagValuesResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:rpc.QueryTagValuesResponse.reply)
  return _s;
}
inline const std::string& QueryTagValuesResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void QueryTagValuesResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryTagValuesResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryTagValuesResponse::release_reply() {
  // @@protoc_insertion_point(field_release:rpc.QueryTagValuesResponse.reply)
  return _impl_.reply_.Release();
}
inline void QueryTagValuesResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QueryTagValuesResponse.reply)
}

// -------------------------------------------------------------------

// QueryNewPointRequest

// string tag = 11;
inline void QueryNewPointRequest::clear_tag() {
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& QueryNewPointRequest::tag() const {
  // @@protoc_insertion_point(field_get:rpc.QueryNewPointRequest.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryNewPointRequest::set_tag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QueryNewPointRequest.tag)
}
inline std::string* QueryNewPointRequest::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:rpc.QueryNewPointRequest.tag)
  return _s;
}
inline const std::string& QueryNewPointRequest::_internal_tag() const {
  return _impl_.tag_.Get();
}
inline void QueryNewPointRequest::_internal_set_tag(const std::string& value) {
  
  _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryNewPointRequest::_internal_mutable_tag() {
  
  return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryNewPointRequest::release_tag() {
  // @@protoc_insertion_point(field_release:rpc.QueryNewPointRequest.tag)
  return _impl_.tag_.Release();
}
inline void QueryNewPointRequest::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tag_.IsDefault()) {
    _impl_.tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QueryNewPointRequest.tag)
}

// -------------------------------------------------------------------

// QueryNewPointResponse

// string reply = 12;
inline void QueryNewPointResponse::clear_reply() {
  _impl_.reply_.ClearToEmpty();
}
inline const std::string& QueryNewPointResponse::reply() const {
  // @@protoc_insertion_point(field_get:rpc.QueryNewPointResponse.reply)
  return _internal_reply();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryNewPointResponse::set_reply(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reply_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:rpc.QueryNewPointResponse.reply)
}
inline std::string* QueryNewPointResponse::mutable_reply() {
  std::string* _s = _internal_mutable_reply();
  // @@protoc_insertion_point(field_mutable:rpc.QueryNewPointResponse.reply)
  return _s;
}
inline const std::string& QueryNewPointResponse::_internal_reply() const {
  return _impl_.reply_.Get();
}
inline void QueryNewPointResponse::_internal_set_reply(const std::string& value) {
  
  _impl_.reply_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryNewPointResponse::_internal_mutable_reply() {
  
  return _impl_.reply_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryNewPointResponse::release_reply() {
  // @@protoc_insertion_point(field_release:rpc.QueryNewPointResponse.reply)
  return _impl_.reply_.Release();
}
inline void QueryNewPointResponse::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    
  } else {
    
  }
  _impl_.reply_.SetAllocated(reply, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reply_.IsDefault()) {
    _impl_.reply_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:rpc.QueryNewPointResponse.reply)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_client_2eproto
